<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
    <title>Basic anomaly statistics for a system trace</title>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <link rel="stylesheet" href="http://billmill.org/css/style.css" />
    <link rel="stylesheet" type="text/css" href="style.css">

</head>
<body>

<div id="datatable"></div>

<script>

    d3.json("data.json",function(error,json){
        if (error) return console.warn(error);
        var table = d3.select("#datatable").append("table");
        var thead = table.append("thead");
        var tbody = table.append("tbody");

        var width = 300,
                height = d3.select("table")[0][0].clientHeight,
                mx = 10;

        // Now add the chart column

        d3.select("#datatable thead").append("th")
                .attr("id", "xaxislabel")
                .attr("width", width + "px");
        thead.append("th").text("eventA");
        thead.append("th").text("eventB");
        thead.append("th").text("sig");
        thead.append("th").text("result");
        thead.append("th").text("low");
        thead.append("th").text("high");

        var tr = tbody.selectAll("tr")
                .data(json)
                .enter().append("tr");
        d3.selectAll("#datatable tbody tr").append("td")
                .attr("id", "chart")
                .attr("width", width + "px");



        var td = tr.selectAll("td")
                .data(function(d) { return ['',d.eventA, d.eventB, d.sig, d.result, d.low, d.high]; })
                .enter().append("td")
                .text(function(d) { return d; });
        var maxData,minData,meanPos,maxWidth;
        var sdSpan=[],
            labelPosArr=[],
            maxArr=[],
            minArr=[],
            barArr=[];

        json.forEach(function(element,index,array){
            var max = Math.max(element.result,element.high);
            var min = Math.min(element.result,element.low);
            maxArr.push(max);
            minArr.push(min);
            sdSpan.push(d3.round((element.mean - min)/element.sd));
            sdSpan.push(d3.round((max -element.mean)/element.sd));
        });
        maxData = d3.max(maxArr);
        minData = d3.min(minArr);
        meanPos = (maxData+minData)*0.5;
        labelPosArr.push(meanPos);//push mean pos into array
        maxWidth =d3.round((maxData-meanPos)/d3.max(sdSpan));

        for(var i = 1; i < 4; ++i)
        {
            labelPosArr.unshift(d3.round(meanPos - i * maxWidth));
            //unshift can push element in front of an array
        }
        for(var i= 1; i < 4;++i)
        {
            labelPosArr.push(d3.round(meanPos+i*maxWidth));
        }

        var xscale = d3.scale.linear()
                .domain([minData,maxData])
                .range([0, 300]);
        var tickLabels = ['3'+'\u03c3','2'+'\u03c3','\u03c3','\u03BC','\u03c3','2'+'\u03c3','3'+'\u03c3'];
        var xAxis = d3.svg.axis()
                        .scale(xscale)
                        .orient("top")
                        .tickValues(labelPosArr)
                        .tickSize(2,0)
                    .tickFormat(function(d,i){ return tickLabels[i] });

        json.forEach(function(element,index,array) {
            var barData={};
            barData.y = 30 ;//*(index+1)
            barData.height = 30;
            var dataWidth= element.result- element.mean;
            var dataSpan = dataWidth/element.sd;
            var x;
            //TODO:optimize the following nested if code block into a helper function
            if (dataWidth > 0){
               if (dataSpan <= 3) {
                   x = d3.scale.linear()
                           .domain([element.mean, element.high])
                           .range([xscale(meanPos), xscale(labelPosArr[labelPosArr.length-1])]);
                   //barData.width = x(element.result) - xscale(meanPos);

               } else {
                   x = d3.scale.linear()
                           .domain([element.high, maxData])
                           .range([xscale(labelPosArr[labelPosArr.length-1]), 300]);
                   //barData.width =x(element.result)- xscale(meanPos);

               }
                barData.x = d3.round(xscale(meanPos));
                barData.width = d3.round(x(element.result)- barData.x);
            } else {
                if (Math.abs(dataSpan) <= 3) {
                    x = d3.scale.linear()
                            .domain([element.low, element.mean])
                            .range([xscale(labelPosArr[0]), xscale(meanPos)]);
//                    barData.x = x(element.result);
//                    barData.width = xscale(meanPos) -barData.x;




                } else {
                    x = d3.scale.linear()
                            .domain([minData, element.low])
                            .range([0, xscale(labelPosArr[0])]);
//                    barData.x = x(element.result);
//                    barData.width = xscale(meanPos) - barData.x;


                }
                barData.x = d3.round(x(element.result));
                barData.width = d3.round(xscale(meanPos) - barData.x);

            }

            barData.sig=element.sig;
            barArr.push(barData);
        });

        //define linear gradinents
        //two type :L-R:G-R L-R:R-G
        var chart = d3.selectAll("#chart").data(barArr).append("svg")
                .attr("width", width + "px")
                .attr("height", 30 + "px");
        var a = d3.rgb(255,0,0);	//red
        var b = d3.rgb(0,255,0);	//green
        var defs = chart.append("defs");

        var linearGradientR = defs.append("linearGradient")
                .attr("id","linearColor")
                .attr("x1","0%")
                .attr("y1","0%")
                .attr("x2","100%")
                .attr("y2","0%");

        linearGradientR.append("stop")
                .attr("offset","0%")
                .style("stop-color",a.toString());

        linearGradientR.append("stop")
                .attr("offset","100%")
                .style("stop-color",b.toString());

        var linearGradientL = defs.append("linearGradient")
                .attr("id","linearColor")
                .attr("x1","0%")
                .attr("y1","0%")
                .attr("x2","100%")
                .attr("y2","0%");

        linearGradientL.append("stop")
                .attr("offset","0%")
                .style("stop-color",b.toString());

        linearGradientL.append("stop")
                .attr("offset","100%")
                .style("stop-color",a.toString());

        chart.append("rect")
                .attr("x", function(d){return d.x;})
                .attr("y", 0)
                .attr("width", function(d){return d.width;})
                .attr("height", 30)
                .style("fill",function(d){
                    if (d.sig =="R"){return "url(#" + linearGradientR.attr("id") + ")"}
                    else if (d.sig =="L"){return "url(#" + linearGradientR.attr("id") + ")"}
                    else{return b;}});

//添加一个矩形，并应用线性渐变
//        var colorRect = svg.append("rect")
//                .attr("x", 15)
//                .attr("y", 200)
//                .attr("width", 200)
//                .attr("height", 30)
//                .style("fill","url(#" + linearGradient.attr("id") + ")")
//                .on("mouseover",function(d){
//                    d3.select(this)
//                            .style("fill","yellow");
//                })
//                .on("mouseout",function(d){
//                    d3.select(this)
//                            .style("fill","url(#" + linearGradient.attr("id") + ")");
//                });

        //append axis
        d3.select("#xaxislabel").append("svg")
                .attr("width", width + "px")
                .attr("height",30 + "px")
                .append("g").attr("class", "axis")
                .attr("width", width+ "px")
                .attr("height",30+ "px")
                .attr("transform", "translate(0,30)")
                .call(xAxis);
//        chart.selectAll(".xaxistick")
//                .data(xscale.ticks(2))
//                .enter().append("line")
//                .attr("x1", function(d) { return xscale(d); })
//                .attr("x2", function(d) { return xscale(d); })
//                .attr("y1", 10)
//                .attr("y2", height)
//                .attr("stroke", "#eee")
//                .attr("stroke-width", 1);

//        chart.selectAll(".line")
//                .data(json)
//                .enter().append("line")
//                .attr("x1", function(d) { return xscale(d.mu); })
//                .attr("y1", function(d) { return yscale(d.dt) + yscale.rangeBand()/2; })
//                .attr("x2", function(d,i) { return rows[i+1] ? xscale(rows[i+1].mu) : xscale(d.mu); })
//                .attr("y2", function(d,i) { return rows[i+1] ? yscale(rows[i+1].dt) + yscale.rangeBand()/2 : yscale(d.dt) + yscale.rangeBand()/2; })
//                .attr("stroke", "#777")
//                .attr("stroke-width", 1);
//
//        var pt = chart.selectAll(".pt")
//                .data(rows)
//                .enter().append("g")
//                .attr("class", "pt")
//                .attr("transform", function(d) { return "translate(" + xscale(d.mu) + "," + (yscale(d.dt) + yscale.rangeBand()/2) + ")"; });
//
//        pt.append("circle")
//                .attr("cx", 0)
//                .attr("cy", 0)
//                .attr("r", radius)
//                .attr("opacity", .5)
//                .attr("fill", "#ff0000");

    });







</script>
</body>
</html>
